
 

// This file is autogenerated. DO NOT EDIT

#pragma once
#include <robotpy_build.h>

#include <..\..\_impl\include\frc\trajectory\TrapezoidProfile.h>




namespace rpygen {

using namespace frc;


template <typename Distance>
inline void bind_frc__TrapezoidProfile(py::module &m, const char * clsName) {

        using namespace frc;
using Distance_t = units::unit_t<Distance>;
using Velocity = units::compound_unit<Distance, units::inverse<units::seconds>>;
using Velocity_t = units::unit_t<Velocity>;
using Acceleration = units::compound_unit<Velocity, units::inverse<units::seconds>>;
using Acceleration_t = units::unit_t<Acceleration>;
using State = typename frc::TrapezoidProfile<Distance>::State;


    py::class_<typename frc::TrapezoidProfile<Distance>>
      cls_TrapezoidProfile(m, clsName);
  
  cls_TrapezoidProfile.doc() =
"A trapezoid-shaped velocity profile.\n"
"\n"
"While this class can be used for a profiled movement from start to finish,\n"
"the intended usage is to filter a reference's dynamics based on trapezoidal\n"
"velocity constraints. To compute the reference obeying this constraint, do\n"
"the following.\n"
"\n"
"Initialization:\n"
"@code{.cpp}\n"
"TrapezoidalMotionProfile::Constraints constraints{kMaxV, kMaxA};\n"
"double previousProfiledReference = initialReference;\n"
"@endcode\n"
"\n"
"Run on update:\n"
"@code{.cpp}\n"
"TrapezoidalMotionProfile profile{constraints, unprofiledReference,\n"
"previousProfiledReference};\n"
"previousProfiledReference = profile.Calculate(timeSincePreviousUpdate);\n"
"@endcode\n"
"\n"
"where `unprofiledReference` is free to change between calls. Note that when\n"
"the unprofiled reference is within the constraints, `Calculate()` returns the\n"
"unprofiled reference unchanged.\n"
"\n"
"Otherwise, a timer can be started to provide monotonic values for\n"
"`Calculate()` and to determine when the profile has completed via\n"
"`IsFinished()`.";
  

    py::class_<typename frc::TrapezoidProfile<Distance>::Constraints>
      cls_Constraints(cls_TrapezoidProfile, "Constraints");
  
  
  


    py::class_<typename frc::TrapezoidProfile<Distance>::State>
      cls_State(cls_TrapezoidProfile, "State");
  
  
  




    cls_TrapezoidProfile
      .def(py::init<typename TrapezoidProfile<Distance>::Constraints, typename TrapezoidProfile<Distance>::State, typename TrapezoidProfile<Distance>::State>(),
      py::arg("constraints"), py::arg("goal"), py::arg("initial")=State{ Distance_t ( 0 ), Velocity_t ( 0 )}, release_gil(), py::doc(
"Construct a TrapezoidProfile.\n"
"\n"
":param constraints: The constraints on the profile, like maximum velocity.\n"
"\n"
":param goal: The desired state when the profile is complete.\n"
"\n"
":param initial: The initial state (usually the current state).")
  )
    
      .def("calculate", &frc::TrapezoidProfile<Distance>::Calculate,
      py::arg("t"), release_gil(), py::doc(
"Calculate the correct position and velocity for the profile at a time t\n"
"where the beginning of the profile was at time t = 0.\n"
"\n"
":param t: The time since the beginning of the profile.")
  )
    
      .def("timeLeftUntil", &frc::TrapezoidProfile<Distance>::TimeLeftUntil,
      py::arg("target"), release_gil(), py::doc(
"Returns the time left until a target distance in the profile is reached.\n"
"\n"
":param target: The target distance.")
  )
    
      .def("totalTime", &frc::TrapezoidProfile<Distance>::TotalTime, release_gil(), py::doc(
"Returns the total time the profile takes to reach the goal.")
  )
    
      .def("isFinished", &frc::TrapezoidProfile<Distance>::IsFinished,
      py::arg("t"), release_gil(), py::doc(
"Returns true if the profile has reached the goal.\n"
"\n"
"The profile has reached the goal if the time since the profile started\n"
"has exceeded the profile's total time.\n"
"\n"
":param t: The time since the beginning of the profile.")
  )
    
;

    cls_Constraints
      .def(py::init<>(), release_gil()
  )
    
      .def(py::init<units::unit_t<Velocity >, units::unit_t<Acceleration >>(),
      py::arg("maxVelocity"), py::arg("maxAcceleration"), release_gil()
  )
    
;

  
  cls_State
      .def(py::self == State()
  )
    
      .def(py::self != State()
  )
    
;

  


    cls_State
  .def(
    py::init<Distance_t, Velocity_t>(),
    py::arg("position") = 0,
    py::arg("velocity") = 0
  )
  .def_readwrite("position", &frc::TrapezoidProfile<Distance>::State::position)
  .def_readwrite("velocity", &frc::TrapezoidProfile<Distance>::State::velocity)
  .def("__repr__", [=](const State &self) {
    return std::string(clsName) + ".State("
      "position=" + std::to_string(self.position()) + ", "
      "velocity=" + std::to_string(self.velocity()) + ")";
  });

}

}; // namespace rpygen